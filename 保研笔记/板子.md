# 第1讲  基础算法
## 1.1. 快速排序
快速排序（Quick Sort）是一种高效的排序算法，通常用于处理大量数据。它的基本思想是通过一个“分治”策略来将数组或列表分成较小的子数组，从而递归地进行排序。以下是快速排序算法的详细讲解：

### 基本思想

快速排序使用分治法将一个数组分成两个子数组。首先，从数组中选择一个元素作为“**基准（pivot）**”，通常选择第一个元素、最后一个元素或随机选择一个元素。然后，将数组分为两部分：一部分包含所有小于基准的元素，另一部分包含所有大于基准的元素。之后，递归地对这两个子数组进行排序，直到整个数组有序。

### 步骤
1. **选择基准**：从数组中选择一个基准元素。常用的方法有选择第一个、最后一个或随机选一个元素作为基准。
2. **分区操作**：将数组重新排列，使得所有小于基准的元素放在基准的左边，所有大于基准的元素放在基准的右边。此时基准元素在数组中的位置是确定的。
3. **递归排序**：对基准左边和右边的子数组分别递归地应用快速排序。
4. **合并结果**：由于子数组在排序时已经相对独立，因此无需额外的合并步骤。

### 时间复杂度
- **最坏情况下**：O(n²)（当每次选择的基准是数组的最小或最大值时，导致分区非常不均匀）。
- **平均情况下**：O(n log n)（分区较均匀时）。
- **最优情况下**：O(n log n)。

### [785. 快速排序 - AcWing题库](https://www.acwing.com/problem/content/787/)
```cpp
#include <stdio.h>
#include <stdlib.h>
#define N 1000010
int n, q[N];
void quick_sort(int q[], int l, int r) {
    if (l >= r) return;
    int i = l - 1, j = r + 1, m = q[(l + r) >> 1];
    while (i < j) {
        do {
            i++;
        } while (q[i] < m);
        do {
            j--;
        } while (q[j] > m);
        if (i < j) {
            int tmp = q[i];
            q[i] = q[j];
            q[j] = tmp;
        }
    }
    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}

int cmp(const void *a, const void *b) {
    int p = *(int *) a;
    int q = *(int *) b;
    return p > q;
}

int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &q[i]);
    }
    qsort(q, n, sizeof q[0], cmp);
    for (int i = 0; i < n; i++) {
        printf("%d ", q[i]);
    }
    return 0;
}

```

### [786. 第k个数 - AcWing题库](https://www.acwing.com/problem/content/788/)
```cpp
#include <stdio.h>
#define N 1000010
int n, k, q[N];

int quick_select(int l, int r, int k) {
    if (l >= r) return q[k];
    int i = l - 1, j = r + 1, m = q[(l + r) >> 1];
    while (i < j) {
        do i++; while (q[i] < m);
        do j--; while (q[j] > m);
        if (i < j) {
            int tmp = q[i];
            q[i] = q[j];
            q[j] = tmp;
        }
    }
    if (k <= j) return quick_select(l, j, k);
    else return quick_select(j + 1, r, k);
}

int main() {
    scanf("%d%d", &n, &k);
    for (int i = 0; i < n; i++) {
        scanf("%d", &q[i]);
    }
    printf("%d\n", quick_select(0, n - 1, k - 1));
    return 0;
}
```

## 1.2. 归并排序

归并排序（Merge Sort）是一种基于分治法（Divide and Conquer）的高效排序算法。它的基本思想是将数组分成更小的部分，分别对这些部分排序，然后再将排序好的部分合并起来形成最终的有序数组。归并排序是稳定排序，且在最坏情况下具有 O(nlog⁡n)O(n \log n)O(nlogn) 的时间复杂度。

### 归并排序的基本思想

归并排序的核心思想是“分而治之”：

- **分（Divide）**：将一个待排序的数组从中间分为两部分，分别对这两部分进行递归排序。
- **治（Conquer）**：将已经排序的两部分合并为一个有序的整体。

### 归并排序的步骤

归并排序可以通过以下步骤来实现：
1. **分解**：将数组从中间分为两部分。
2. **递归排序**：对左半部分和右半部分分别进行递归排序。
3. **合并**：将排序好的两部分进行合并，形成最终的有序数组。

### 归并排序的特点
- **稳定性**：归并排序是稳定的，意味着它不会改变相等元素的相对顺序。
- **时间复杂度**：在最坏、最优和平均情况下，归并排序的时间复杂度都是$O(n \log n)$，其中 $n$ 是数组的元素数量。
- **空间复杂度**：归并排序的空间复杂度为 $O(n)$，因为它需要额外的数组来存放合并后的结果。
- **适用性**：归并排序适用于排序大规模的数据，特别是在外部排序中（例如对不能一次性加载到内存的大数据进行排序），归并排序非常有效。

### [787. 归并排序 - AcWing题库](https://www.acwing.com/problem/content/789/)

```cpp
#include <stdio.h>
#define N 1000010

int n, q[N], q2[N];

void merge_sort(int l, int r) {
    if (l >= r) return;
    int m = l + r >> 1;
    merge_sort(l, m);
    merge_sort(m + 1, r);
    int i = l, j = m + 1, index = 0;
    while (i <= m && j <= r) {
        if (q[i] <= q[j]) q2[index++] = q[i++];
        else q2[index++] = q[j++];
    }
    while (i <= m) {
        q2[index++] = q[i++];
    }
    while (j <= r) {
        q2[index++] = q[j++];
    }
    for (i = l, j = 0; i <= r; i++, j++) {
        q[i] = q2[j];
    }
}

int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &q[i]);
    }
    merge_sort(0, n - 1);
    for (int i = 0; i < n; i++) {
        printf("%d ", q[i]);
    }
    return 0;
}
```

### [788. 逆序对的数量 - AcWing题库](https://www.acwing.com/problem/content/790/)
```cpp
#include <stdio.h>
#define N 10000010
int n, a[N], tmp[N];
long long res = 0;
long long merge_sort(int l, int r) {
    // !!!!
    if (l >= r) return;
    int m = (l + r) >> 1;
    
    merge_sort(l, m);
    merge_sort(m + 1, r);
    int i = l, j = m + 1, k = 0;
    while (i <= m && j <= r) {
        if (a[i] <= a[j]) {
            tmp[k++] = a[i++];
        } else {
            res += m - i + 1;
            tmp[k++] = a[j++];
        }
    }
    while (i <= m) {
        tmp[k++] = a[i++];
    }
    while (j <= r) {
        tmp[k++] = a[j++];
    }
    for (i = l, j = 0; i <= r; i++, j++) {
        a[i] = tmp[j];
    }
}

int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }
    merge_sort(0, n - 1);
    printf("%lld\n", res);
    return 0;
}
```

## 1.3. 二分
### [789. 数的范围 - AcWing题库](https://www.acwing.com/problem/content/791/)
```cpp
#include <stdio.h>
#define N 100010
int n, q, k, a[N];

int main() {
    scanf("%d%d", &n, &q);
    for (int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }
    while (q--) {
        scanf("%d", &k);
        int l = 0, r = n - 1;
        while (l < r) {
            int mid = l + r >> 1;
            if (a[mid] >= k) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        if (a[l] != k) {
            printf("-1 -1\n");
            continue;
        }
        printf("%d ", l);
        l = 0, r = n - 1;
        while (l < r) {
            int mid = l + r + 1 >> 1;
            if(a[mid] <= k) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        printf("%d\n", l);
        
    }
    return 0;
}
```

### [790. 数的三次方根 - AcWing题库](https://www.acwing.com/problem/content/792/)
```cpp
#include <stdio.h>
double n;
int main() {
    scanf("%lf", &n);
    double l = -10000, r = 10000, mid;
    
    while (r - l >= 1e-10) {
        mid = (l + r) / 2;
        if (mid * mid * mid < n) {
            l = mid;
        } else {
            r = mid;
        }
    }
    printf("%lf\n", r); 
    return 0;
}
```

## 1.4. 前缀和与差分
### [795. 前缀和 - AcWing题库](https://www.acwing.com/problem/content/797/)
```cpp
#include <stdio.h>
#define N 100010
int n, m, l, r;
int a[N], s[N];

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        s[i] = s[i - 1] + a[i];
    }
    while (m--) {
        scanf("%d%d", &l, &r);
        printf("%d\n", s[r] - s[l - 1]);
    }
    return 0;
}
```

### [796. 子矩阵的和 - AcWing题库](https://www.acwing.com/problem/content/798/)
```cpp
#include <stdio.h>
#define N 1010
int n, m, q, x1, x2, y1, y2;
int a[N][N], s[N][N];

int main() {
    scanf("%d%d%d", &n, &m, &q);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            scanf("%d", &a[i][j]);
            s[i][j] = s[i - 1][j] + s[i][j - 1] + a[i][j] - s[i - 1][j - 1];
        }
    }
    while (q--) {
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        printf("%d\n", s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]);
    }
    return 0;
}
```

### [797. 差分 - AcWing题库](https://www.acwing.com/problem/content/description/799/)
```cpp
#include <stdio.h>
#define N 100010
int n, m, l, r, c;
int a[N], s[N];

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        s[i] = a[i] - a[i - 1];
    }
    while (m--) {
        scanf("%d%d%d", &l, &r, &c);
        s[l] += c;
        s[r + 1] -= c;
    }
    for (int i = 1; i <= n; i++) {
        a[i] = s[i] + a[i - 1];
        printf("%d ", a[i]);
    }
    return 0;
}
```

	### 















---
# 第2讲 数据结构
## 2.10. 堆
### [839. 模拟堆 - AcWing题库](https://www.acwing.com/problem/content/841/)
需要使用一个双向指针记录每个元素是第几个插入的（即`cur_size`）。
```cpp
#include <stdio.h>
#include <string.h>
#define N 100010
int h[N], ph[N], hp[N]; // h 从 idx == 1 开始存
int cur_size, idx;

void swap(int a, int b) {
    int tmp;
    // 交换堆中的元素
    tmp = h[a], h[a] = h[b], h[b] = tmp;
    // 交换hp
    tmp = hp[a], hp[a] = hp[b], hp[b] = tmp;
    // 交换ph
    tmp = ph[hp[a]], ph[hp[a]] = ph[hp[b]], ph[hp[b]] = tmp;
}

// 下沉操作
void down(int u) {
    int t = u;
    if (2 * u <= cur_size && h[2 * u] < h[t]) {
        t = 2 * u;
    }
    if (2 * u + 1 <= cur_size && h[2 * u + 1] < h[t]) {
        t = 2 * u + 1;
    }
    if (t != u) {
        swap(t, u);
        down(t);
    }
}

void up(int u) {
    if (u / 2 >= 1 && h[u / 2] > h[u]) {
        swap(u, u / 2);
        up(u / 2);
    }
}

void insert(int x) {
    idx++, cur_size++;
    h[cur_size] = x;
    ph[idx] = cur_size;
    hp[cur_size] = idx;
    up(cur_size); 
}

void delete_heap_min() {
    swap(1, cur_size);
    cur_size--;
    down(1);
}

void delete_heap_k(int k) {
    int u = ph[k];
    swap(u, cur_size);
    cur_size--;
    down(u);
    up(u);
}

void change(int k, int x) {
    int u = ph[k];
    h[ph[k]] = x;
    down(ph[k]);
    up(ph[k]);
    
}



int n, k, x;
char op[10];
int main() {
    scanf("%d", &n);
    while (n--) {
        scanf("%s", op);
        if (strcmp(op, "I") == 0) {
            scanf("%d", &x);
            insert(x);
        } else if (strcmp(op, "PM") == 0) {
            printf("%d\n", h[1]);
        } else if (strcmp(op, "DM") == 0) {
            delete_heap_min();
        } else if (strcmp(op, "D") == 0) {
            scanf("%d", &k);
            delete_heap_k(k);
        } else if (strcmp(op, "C") == 0) {
            scanf("%d%d", &k, &x);
            change(k, x);
        }
    }
    return 0;
}
```



# 第3讲 搜索与图论
![[Pasted image 20240822145347.png]]
## 3.1. DFS
### [842. 排列数字 - AcWing题库](https://www.acwing.com/problem/content/844/)

思路就是用递归的方式进行深搜，每次考虑的是下一位可以填哪些数字。

```cpp
#include <stdio.h>
#define N 10
int n;
int out[N];
int use[N];

// u表示该考虑第几位，从0开始
void dfs(int u) {
    if (u == n) {
        for(int i = 0; i < n; i++) {
            printf("%d ", out[i]);
        }
        printf("\n");
        return;
    }
    // u < n
    for(int i = 1; i <= n; i++) {
        if (!use[i]) {
            out[u] = i;
            use[i] = 1;
            dfs(u + 1);
            use[i] = 0;
        }
    }
    
}
int main() {
    scanf("%d", &n);
    dfs(0);
    return 0;
}
```


### [843. n-皇后问题 - AcWing题库](https://www.acwing.com/problem/content/845/)

也是深搜，考虑的是下一行棋子可以放在哪些位上。`!lie[l] && !dj[h + l] && !fdj[n - h + l]`。 注意对角线和反对角线的标号技巧，可以画图辅助计算。
```cpp
#include <stdio.h>
#define N 20

char out[N][N];
int n;
int lie[N], dj[N], fdj[N];

int dfs(int h) {
    if(h == n) {
        for(int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                printf("%c", out[i][j]);
            }
            printf("\n");
        }
        printf("\n");
    }
    for(int l = 0; l < n; l++) {
        if (!lie[l] && !dj[h + l] && !fdj[n - h + l]) {
            out[h][l] = 'Q';
            lie[l] = dj[h + l] = fdj[n - h + l] = 1;
            dfs(h + 1);
            out[h][l] = '.';
            lie[l] = dj[h + l] = fdj[n - h + l] = 0;
        }
    }
}

int main() {
    scanf("%d", &n);
    for (int h = 0; h < n; h++) {
        for (int l = 0; l < n; l++) {
            out[h][l] = '.';
        }
    }
    dfs(0);
    return 0;
}

```


## 3.2. BFS

bfs基本思路：维护一个可以扩展元素的队列
```
while 队列q非空:
	取出队头 t <- q
	找到t的扩展元素
	将扩展元素放回队列
```

### [844. 走迷宫 - AcWing题库](https://www.acwing.com/problem/content/846/)

```cpp
#include <stdio.h>
#define N 110
// 队列
int qx[N * N], qy[N * N];
int hh = 0, tt = -1;
int putin[N][N]; // 输入
int d[N][N]; // 距离
int n, m;

void push(int x, int y) {
    qx[++tt] = x;
    qy[tt] = y;
}

void pop() {
    hh++;
}

int empty() {
    return hh > tt;
}

int queryx() {
    return qx[hh];
}
int queryy() {
    return qy[hh];
}

int bfs() {
    while(!empty()) {
        int x = queryx();
        int y = queryy();
        pop();
        int dx[4] = {1, 0, -1, 0};
        int dy[4] = {0, 1, 0, -1};
        for (int i = 0; i < 4; i++) {
            int newx = x + dx[i];
            int newy = y + dy[i];
            // printf("%d %d %d %d\n", newx, newy, putin[newx][newy], d[newx][newy]);
            if (newx >= 1 && newx <= n && newy >= 1 && newy <= m && putin[newx][newy] == 0 && d[newx][newy] == -1 ) {
                d[newx][newy] = d[x][y] + 1;
                // printf("%d%d\n", newx, newy);
                push(newx, newy);
            }
        }
    }
    return d[n][m];
}
int main() {
    scanf("%d%d", &n, &m);
    
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            scanf("%d", &putin[i][j]);
        }
    }
    
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            d[i][j] = -1;
        }
    }
    
    d[1][1] = 0;
    push(1, 1);
    printf("%d", bfs());
    return 0;
}

```

### [845. 八数码 - AcWing题库](https://www.acwing.com/problem/content/847/)
难点在于怎么表示网格？转化成字符串，用哈希。
```cpp
// 哈希采用拉链法
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define HASH_SIZE 1000003
typedef struct Node {
    char ch[10];
    int dis;
    struct Node* next;
} Node;

// 1. ======= 哈希表相关 ========
Node* hash_table[HASH_SIZE];

// 哈希函数
int hash(char ch[]) {
    long long res = 0, i = 0;
    while (ch[i] != '\0') {
        res = res * 31 + ch[i] - '1';
        i++;
        // printf("%lld\n", res);
    }
    return res % HASH_SIZE;
}

// 插入哈希表
void insert(char ch[], int distance) {
    int idx = hash(ch);
    Node* new_node = (Node *)malloc(sizeof(Node));
    strcpy(new_node -> ch, ch);
    new_node -> dis = distance;
    new_node -> next = hash_table[idx];
    hash_table[idx] = new_node;
}

// 查找哈希表，返回距离
int find(char ch[]) {
    int idx = hash(ch);
    Node *node = hash_table[idx];
    while (node) {
        if (strcmp(ch, node -> ch) == 0) {
            return node -> dis;
        }
        node = node -> next;
    }
    return -1;
}

// 2. ====== bfs 相关 ============
Node queue[HASH_SIZE];
int hh = 0, tt = -1;
void push(Node n) {
    queue[++tt] = n;
}

Node pop() {
    return queue[hh++];
}

int empty() {
    return tt < hh;
}

int find_x(char ch[]) {
    int idx = 0;
    while (ch[idx] != 'x') {
        idx++;
    }
    return idx;
}

char start[10];
char end[10] = {'1', '2', '3', '4', '5', '6', '7', '8', 'x', '\0'};
int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1}; // 方向数组

int bfs() {
    // 初始化队列和哈希表
    Node head;
    strcpy(head.ch, start);
    head.dis = 0;
    push(head);
    
    insert(start, 0);
    
    while (!empty()) {
        Node node = pop();
        // 如果找到了，就返回
        if (strcmp(node.ch, end) == 0) {
            return node.dis;
        }
        
        // 否则，没找到，则尝试拓展
        int idx_x = find_x(node.ch);
        int ii = idx_x / 3, jj = idx_x % 3;
        for (int i = 0; i < 4; i++) {
            int newx = ii + dx[i], newy = jj + dy[i];
            // 没有越界
            if (0 <= newx && newx < 3 && 0 <= newy && newy < 3) {
                char new_ch[10];
                strcpy(new_ch, node.ch);
                int other_idx = newx * 3 + newy;
                new_ch[idx_x] = new_ch[other_idx];
                new_ch[other_idx] = 'x';
                // 还没考虑过
                if (find(new_ch) == -1) {
                    // 入队，还要更新距离
                    Node nn;
                    strcpy(nn.ch, new_ch);
                    nn.dis = node.dis + 1;
                    push(nn);
                    insert(new_ch, node.dis + 1);
                }
            }
        }
        
    }

    // 如果无法达到目标状态，返回-1
    return -1;
}

int main() {
    for (int i = 0; i < 9; i++) {
        scanf(" %c", &start[i]);
    }
    printf("%d\n", bfs());
    return 0;
}
```

## 3.3. 树与图的深度优先遍历

### [846. 树的重心 - AcWing题库](https://www.acwing.com/problem/content/848/)

改造一下dfs函数。函数返回以当前节点为根的子树的节点个数。由于是dfs，所以一定会处理完一个子树再处理下一个。  
稀疏图，用邻接表存。
```cpp
#include <stdio.h>
// 无向图要开2倍！！
#define N 200010

int h[N], e[N], ne[N], idx = 0;
void add(int a, int b) {
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

int n, m = N, a, b;
int st[N];
// 返回以u为根结点的子树点的数量
int dfs(int u) {
    int res = 1; // 至少为1（只有根节点）
    int max_son_num = -1;
    st[u] = 1;
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (st[j] == 0) {
            int t = dfs(j);
            res += t;
            max_son_num = t > max_son_num ? t : max_son_num;
        }
    }
    max_son_num = max_son_num > n - res ? max_son_num : n - res;
    m = max_son_num < m ? max_son_num : m;
    return res;
}
int main() {
    for (int i = 0; i < N; i++) {
        h[i] = -1;
    }
    scanf("%d", &n);
    for (int i = 0; i < n - 1; i ++) {
        scanf("%d%d", &a, &b);
        add(a, b);
        add(b, a);
    }
    dfs(1);
    printf("%d\n", m);
    return 0;
}
```

## 3.4. 树与图的广度优先遍历
### [847. 图中点的层次 - AcWing题库](https://www.acwing.com/problem/content/849/)
这道题就是一个求最短路（所有边长都为1）。

```cpp
#include <stdio.h>
#define N 100010
int h[N], e[N], ne[N], idx = 0;

int add(int a, int b) {
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

int n, m, a, b;

int queue[N], d[N];
int hh = 0, tt = -1;
void push(int x) {
    queue[++tt] = x;
}

int pop() {
    return queue[hh++];
}

int empty() {
    return hh > tt;
}

int bfs() {
    for(int i = 0; i < N; i++) {
        d[i] = -1;
    }
    push(1);
    d[1] = 0;
    while(!empty()) {
        int x = pop();
        if (x == n) {
            return d[x];
        }
        for (int i = h[x]; i != -1; i = ne[i]) {
            if (d[e[i]] == -1) {
                d[e[i]] = d[x] + 1;
                push(e[i]);
            }
        }
    }
    return -1;
}

int main() {
    for (int i = 0; i < N; i++) {
        h[i] = -1;
    }
    scanf("%d%d", &n, &m);
    while (m--) {
        scanf("%d%d", &a, &b);
        add(a, b);
    }
    printf("%d\n", bfs());
    return 0;
}
```

## 3.5. Dijkstra算法
边权都要为正值。   
Dijkstra算法不能处理带负权边的图的原因主要在于其核心机制依赖于“贪心策略”，即每次选择当前已知的最短路径。这种策略假设在某个时刻，已经找到的路径是最优的，不会再被后续的边更新。   

具体来说，Dijkstra算法在选择路径时，依据当前的最小路径值（从起点到某个顶点的最短距离）进行扩展。然而，如果图中存在负权边，这一假设就可能被破坏。例如，假设从顶点A到顶点B的最短路径初步确定为10，但图中存在一条负权边，使得从另一个顶点C经过该负权边到达B的路径的权重和为5。在这种情况下，Dijkstra算法不会再考虑这条路径，因为它已经“认为”A到B的路径是最短的。
### [849. Dijkstra求最短路 I - AcWing题库](https://www.acwing.com/problem/content/851/)
稠密图，n很小，本题为500.

- **初始化：**
    - 将图中所有顶点的最短路径估计值设为无穷大（表示未访问），源点的最短路径估计值设为0。
    - 使用一个优先队列（通常使用最小堆实现）来跟踪待处理的顶点，根据当前的最短路径估计值排序。
- **选择顶点：**
    - 每次从优先队列中取出最小距离的顶点（即目前距离源点最近的顶点），记为当前顶点。
- **更新路径：**
    - 对当前顶点的所有邻接顶点，检查从源点经过当前顶点到达这些邻接顶点的路径是否比当前已知的最短路径更短。如果更短，则更新邻接顶点的最短路径估计值，并将其加入优先队列中。
- **重复步骤2和3：**
    - 重复选择未访问的顶点并更新路径的过程，直到所有顶点都被访问过或者优先队列为空。
- **结束：**
    - 当所有顶点都被访问后，源点到各个顶点的最短路径就已经确定。
```cpp
#include <stdio.h>
#define N 510
int g[N][N];
int dist[N];
int st[N];
int n, m, x, y, z;
int dijkstra(int u, int v) {
    for (int i = 0; i < N; i++) {
        dist[i] = 0x3f3f3f3f;
    }
    dist[u] = 0;
    for (int i = 0; i < n; i++) {
        int t = -1;
        for (int j = 1; j <= n; j++) {
            if (st[j] == 0 && (t == -1 || dist[j] < dist[t])) {
                t = j;
            }
        }
        st[t] = 1;
        for (int j = 1; j <= n; j++) {
            dist[j] = dist[t] + g[t][j] < dist[j] ? dist[t] + g[t][j] : dist[j];
        }
    }
    return dist[v] == 0x3f3f3f3f ? -1 : dist[v];
}


int main() {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            g[i][j] = 0x3f3f3f3f;
        }
    }
    scanf("%d%d", &n, &m);
    while (m--) {
        scanf("%d%d%d", &x, &y, &z);
        g[x][y] = z < g[x][y] ? z : g[x][y];
        g[y][x] = z < g[y][x] ? z : g[y][x];
    }
    printf("%d\n", dijkstra(1, n));
    return 0;
}
```


### [850. Dijkstra求最短路 II - AcWing题库](https://www.acwing.com/problem/content/852/)

> 堆优化版的dijkstra算法，适用于稀疏图。

```cpp
#include <stdio.h>
#include <string.h>

#define N 150010
#define INF 0x3f3f3f3f

int h[N], e[N], ne[N], w[N], idx;
int dist[N], st[N];
int heap[N], ph[N], hp[N]; // h从idx == 1开始存，ph是图中的节点在堆中的下标
int cur_size;

void swap(int a, int b) {
    int tmp;
    tmp = heap[a], heap[a] = heap[b], heap[b] = tmp;
    tmp = hp[a], hp[a] = hp[b], hp[b] = tmp;
    tmp = ph[hp[a]], ph[hp[a]] = ph[hp[b]], ph[hp[b]] = tmp;
}

void down(int u) {
    int t = u;
    if (2 * u <= cur_size && dist[heap[2 * u]] < dist[heap[t]]) {
        t = 2 * u;
    }
    if (2 * u + 1 <= cur_size && dist[heap[2 * u + 1]] < dist[heap[t]]) {
        t = 2 * u + 1;
    }
    if (t != u) {
        swap(t, u);
        down(t);
    }
}

void up(int u) {
    if (u / 2 >= 1 && dist[heap[u / 2]] > dist[heap[u]]) {
        swap(u, u / 2);
        up(u / 2);
    }
}


// 插入节点x
void insert(int x) {
    cur_size++;
    heap[cur_size] = x;
    ph[x] = cur_size;
    hp[cur_size] = x;
    up(cur_size); 
}

void delete_heap_min() {
    swap(1, cur_size);
    cur_size--;
    down(1);
}

// 把第k个节点的距离更新为x
void change(int k, int x) {
    int u = ph[k];
    dist[k] = x;
    down(u);
    up(u);
}

void add(int x, int y, int c) {
    e[idx] = y;
    w[idx] = c;
    ne[idx] = h[x];
    h[x] = idx++;
}

int dijkstra(int n) {
    for (int i = 0; i < N; i++) {
        dist[i] = INF;
    }
    
    dist[1] = 0;
    insert(1);

    while (cur_size) {
        int ver = heap[1];
        delete_heap_min();

        if (st[ver]) continue;
        st[ver] = 1;

        for (int i = h[ver]; i != -1; i = ne[i]) {
            int j = e[i];
            if (dist[j] > dist[ver] + w[i]) {
                dist[j] = dist[ver] + w[i];
                if (ph[j] == 0) insert(j);
                else change(j, dist[j]);
            }
        }
    }

    if (dist[n] == INF) return -1;
    return dist[n];
}

int main() {
    memset(h, -1, sizeof h);
    int n, m;
    scanf("%d%d", &n, &m);
    
    while (m--) {
        int x, y, c;
        scanf("%d%d%d", &x, &y, &c);
        add(x, y, c);
    }

    printf("%d\n", dijkstra(n));

    return 0;
}

```


## 3.6. Bellman-fold算法

Bellman-Ford算法是一种用于计算单源最短路径的算法，它能够处理带有负权边的加权有向图。与Dijkstra算法不同，Bellman-Ford算法可以正确处理图中存在负权边的情况，甚至可以检测到负权回路（负权回路会导致最短路径无法定义）。

### 算法步骤

1. **初始化**：
    - 将源节点的距离设为0，其他所有节点的距离设为无穷大（表示尚未访问）。
    - 初始化一个包含所有边的列表。
2. **松弛操作**：
    - 对于图中的每一条边 `(u, v)`，检查是否可以通过边 `(u, v)` 减少节点 `v` 的当前最短路径距离。如果可以，则更新 `v` 的距离。
    - 重复上述操作 `|V|-1` 次（其中 `|V|` 是图中节点的数量）。每次迭代，所有边都会被处理一遍。
3. **检测负权回路**：
    - 在执行完 `|V|-1` 次松弛操作后，再遍历一遍所有边。如果在这个过程中还能继续松弛任何节点的距离，那么说明图中存在负权回路。

> 可以处理求不超过k条的最短路的问题。


### [853. 有边数限制的最短路 - AcWing题库](https://www.acwing.com/problem/content/855/)

```cpp
#include <stdio.h>
#define N 510
#define M 10010
#define INF 0x3f3f3f3f
typedef struct Edge {
    int a;
    int b;
    int w;
} Edge;

Edge e[M];
int n, m, k;
int x, y, z;
int idx = 0;
int dist[N], backup[N];
int bellman_fold() {
    for (int i = 0; i < N; i++) {
        dist[i] = INF;
    }
    dist[1] = 0;
    for (int i = 0; i < k; i++) {
        memcpy(backup, dist, sizeof dist);
        for (int j = 0; j < m; j++) {
            int a, b, w;
            a = e[j].a, b = e[j].b, w = e[j].w;
            dist[b] = backup[a] + w < dist[b] ? backup[a] + w : dist[b];
        }
    }
    return dist[n];
}


int main() {
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 0; i < m; i++) {
        scanf("%d%d%d", &e[i].a, &e[i].b, &e[i].w);
    }
    bellman_fold() > INF / 2 ? printf("impossible\n") : printf("%d\n", bellman_fold());
    return 0;
}
```

## 3.7. SPFA算法

SPFA（Shortest Path Faster Algorithm）算法是Bellman-Ford算法的优化版本，用于解决单源最短路径问题。

### 算法原理

SPFA算法与Bellman-Ford算法的核心思想相似，也通过松弛操作更新节点的最短路径。然而，SPFA在执行松弛操作时并不盲目遍历所有边，而是使用队列来智能地选择哪些节点需要松弛，从而避免不必要的计算。

### 算法步骤

1. **初始化**：
    - 将源节点的距离设为0，其他所有节点的距离设为无穷大。
    - 初始化一个空队列，将源节点加入队列。
2. **队列处理**：
    - 当队列不为空时，从队列中取出一个节点 `u`。
    - 对与 `u` 相邻的每个节点 `v`，检查是否可以通过 `u` 松弛 `v` 的当前距离。如果可以，则更新 `v` 的距离，并将 `v` 加入队列（如果 `v` 不在队列中）。
	- 需要维护一个st数组，以知道该节点是否被更新了。
3.  **重复以上步骤**：
    - 不断重复从队列中取节点并执行松弛操作，直到队列为空为止。

### [851. spfa求最短路 - AcWing题库](https://www.acwing.com/problem/content/853/)

```cpp
#include <stdio.h>
#define N 100010
#define INF 0x3f3f3f3f
int n, m, x, y, z;

// 邻接表
int h[N], e[N], ne[N], idx;
int w[N];
int add(int a, int b, int c) {
    e[idx] = b;
    w[idx] = c;
    ne[idx] = h[a];
    h[a] = idx++; 
}

int queue[N]; 
int hh = 0, tt = -1;

void push(int x) {
    queue[++tt] = x;
}

int pop() {
    return queue[hh++];
}

int empty() {
    return hh > tt;
}

int d[N], st[N];
int spfa() {
    for (int i = 0; i < N; i++) {
        d[i] = INF;
    }
    d[1] =0;
    push(1);
    st[1] = 1;
    while (!empty()) {
        int t = pop();
        st[t] = 0;
        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            if (d[t] + w[i] < d[j]) {
                d[j] = d[t] + w[i];
                if (!st[j]) {
                    push(j);
                    st[j] = 1;
                }
                
            }
        }
    }
    return d[n];
}

int main() {
    for (int i = 0; i < N; i++) {
        h[i] = -1;
    }
    scanf("%d%d", &n, &m);
    for (int i = 0; i < m; i++) {
        scanf("%d%d%d", &x, &y, &z);
        add(x, y, z);
    }
    int ans = spfa();
    if (ans > INF / 2) printf("impossible");
    else printf("%d\n", ans);
    return 0;
}
```

### [852. spfa判断负环 - AcWing题库](https://www.acwing.com/problem/content/854/)
思路是维护一个cnt数组，统计当前到该点的最短路所经过的节点个数。若某一时刻到某点的最短路所经过的节点个数>=n，根据抽屉原理，一定存在负环。
```cpp
#include <stdio.h>
#define N 10010
#define M 10010
int n, m, x, y, z;
int h[N], e[M], ne[M], idx;
int w[N];
int add(int a, int b, int c) {
    e[idx] = b;
    w[idx] = c;
    ne[idx] = h[a];
    h[a] = idx++;
}

int queue[N * M];
int hh = 0, tt = -1;
int dist[N], st[N], cnt[N];

void push(int x) {
    queue[++tt] = x;
}

int pop() {
    return queue[hh++];
}

int empty() {
    return hh > tt;
}

int spfa() {
    for (int i = 1; i <= n; i++) {
        push(i);
        st[i] = 1;
    }
    while(!empty()) {
        int t = pop();
        st[t] = 0;
        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            if (dist[j] > dist[t] + w[i]) {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) {
                    return 1;
                }
                if (!st[j]) {
                    st[j] = 1;
                    push(j);
                }
            }
        }
    }
    return 0;
}


int main() {
    for (int i = 0; i < N; i++) {
        h[i] = -1;
    }
    scanf("%d%d", &n, &m);
    for (int i = 0; i < m; i++) {
        scanf("%d%d%d", &x, &y, &z);
        add(x, y, z);
    }
    int res = spfa();
    if (res) printf("Yes\n");
    else printf("No\n");
    return 0;
}
```

## 3.8. Folyd算法

Floyd算法（也称为Floyd-Warshall算法）是一种用于计算**任意两点间的最短路径**的动态规划算法。它可以处理带权重的有向图或无向图，且能处理带有负权边的图，但不允许负权回路存在。

### 算法概述

Floyd算法的核心思想是通过逐步引入中间顶点来更新最短路径。对于图中的每一对顶点 `(i, j)`，初始时假设已知的最短路径仅使用图中直接相连的边。接着，算法逐步尝试引入每一个顶点 `k` 作为中间点，以检查是否通过 `k` 可以找到一条更短的路径。如果引入 `k` 使得路径 `(i, k) + (k, j)` 的距离小于当前已知的直接路径 `(i, j)`，则更新最短路径的距离。

### 输入和输出

- **输入**: 图的邻接矩阵 `dist`，其中 `dist[i][j]` 表示从顶点 `i` 到顶点 `j` 的边的权重。如果 `i` 和 `j` 之间没有边，则 `dist[i][j]` 初始化为无穷大。
    
- **输出**: 更新后的邻接矩阵 `dist`，其中 `dist[i][j]` 表示顶点 `i` 到顶点 `j` 的最短路径的权重。
    

### 时间复杂度

Floyd算法的时间复杂度为 `O(n^3)`，其中 `n` 是图中顶点的数量。由于它使用了三重循环，因此在顶点数量较多时，计算量较大。

### 主要特点

- **全面性**: 它能找到任意两点间的最短路径，而不仅仅是从单一源点到其他顶点的最短路径。
    
- **处理负权边**: Floyd算法可以处理带有负权边的图，只要图中不存在负权回路（否则结果无效，因为最短路径可以无限减小）。
    
- **简单性**: 该算法的实现相对简单且直观。
    

### 应用场景

- 适用于图中所有顶点之间的最短路径问题，特别是那些需要多次查询任意两点间最短路径的情况。
    
- 适合处理较小规模的图，由于其 `O(n^3)` 的时间复杂度，在处理较大规模的图时计算成本较高。

### [854. Floyd求最短路 - AcWing题库](https://www.acwing.com/problem/content/856/)

```cpp
#include <stdio.h>
#define N 210
#define M 20010
#define INF 0x3f3f3f3f
int n, m, k, x, y, z;

int g[N][N];

int min(int a, int b) {
    return a < b ? a : b;
}

void floyd() {
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                g[i][j] = min(g[i][k] + g[k][j], g[i][j]);
            }
        }
    }
}

int main() {
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (i == j) {
                g[i][j] = 0;
            } else {
                g[i][j] = INF;
            }
        }
    }
    for (int i = 0; i < m; i++) {
        scanf("%d%d%d", &x, &y, &z);
        g[x][y] = min(g[x][y], z);
    }
    floyd();
    while (k--) {
        scanf("%d%d", &x, &y);
        int ans = g[x][y];
        if (ans > INF / 2) printf("impossible\n");
        else printf("%d\n", ans);
    }
    return 0;
}
```

---
# 第4讲  数学知识

## 4.1. 质数

### [866. 试除法判定质数 - AcWing题库](https://www.acwing.com/problem/content/868/)

```cpp
#include <stdio.h>
int n, a;
int zs(int x) {
    if (x < 2)  return 0;
    for (int i = 2; i <= x / i; i++) {
        if (x % i == 0)  return 0;
    }
    return 1;
}

int main() {
    scanf("%d", &n);
    while (n--) {
        scanf("%d", &a);
        if (zs(a)) printf("Yes\n");
        else printf("No\n");
    }
    
    return 0;
}
```

### [867. 分解质因数 - AcWing题库](https://www.acwing.com/problem/content/869/)

```cpp
#include <stdio.h>
int n, a;

void sc(int x) {
    int z = 0;
    for (int i = 2; i <= x / i; i++) {
        if (x % i == 0) {
            z = 0;
            while (x % i == 0) {
                x /= i; z++;
            }
            printf("%d %d\n", i, z);
        }
    }
    if (x > 1) printf("%d 1\n", x);
    puts("");
}

int main() {
    scanf("%d", &n);
    while (n--) {
        scanf("%d", &a);
        sc(a);
    }
    return 0;
}

```

### [868. 筛质数 - AcWing题库](https://www.acwing.com/problem/content/description/870/)
```cpp
#include <stdio.h>
#define N 1000010
int n;
int cnt, prime[N], st[N];

void get_primes(int x) {
    for (int i = 2; i <= x; i++) {
        if (st[i] == 0) {
            prime[cnt++] = i;
            for (int j = 2 * i; j <= x; j += i) {
                st[j] = 1;
            }
        }
    }
}

int main() {
    scanf("%d", &n);
    get_primes(n);
    printf("%d\n", cnt);
    return 0;
}
```

## 4.2. 约数
### [869. 试除法求约数 - AcWing题库](https://www.acwing.com/problem/content/871/)
```cpp
#include <stdio.h>
#define N 10000010

int n, a;
int heap[N];
int cur_size = 0;

void down(int u) {
    int t = u;
    if (2 * u <= cur_size && heap[2 * u] < heap[t]) {
        t = 2 * u;
    }
    if (2 * u + 1 <= cur_size && heap[2 * u + 1] < heap[t]) {
        t = 2 * u + 1;
    }
    if (t != u) {
        int tmp = heap[t];
        heap[t] = heap[u];
        heap[u] = tmp;
        down(t);
    }
}

void up(int u) {
    if (u / 2 >= 1 && heap[u / 2] > heap[u]) {
        int tmp = heap[u];
        heap[u] = heap[u / 2];
        heap[u / 2] = tmp;
        up(u / 2);
    }
}

void add(int x) {
    heap[++cur_size] = x;
    up(cur_size);
    // printf("!!%d\n", heap[1]);
}


void yueshu(int x) {
    cur_size = 0;
    for (int i = 1; i <= x / i; i++) {
        if (x % i == 0) {
            add(i);
            if (i != x / i) {
                add(x / i);
            }
        }
    }
}

int main() {
    scanf("%d", &n);
    while (n--) {
        scanf("%d", &a);
        yueshu(a);
        
        while (cur_size > 0) {
            int tmp = heap[cur_size];
            heap[cur_size] = heap[1];
            heap[1] = tmp;
            printf("%d ", heap[cur_size--]);
            down(1);
        }
        puts("");
    }
    return 0;
    
}
```

### [870. 约数个数 - AcWing题库](https://www.acwing.com/problem/content/872/)

要计算一个数的约数的个数，可以按照以下步骤进行：

1. **分解质因数**：将该数 \( N \) 分解为若干个质数的乘积，假设分解结果为：
   $$
   N = p_1^{a_1} \times p_2^{a_2} \times \dots \times p_k^{a_k}
   $$
   其中，( $p_1, p_2, \dots, p_k$) 是质数，\( $a_1, a_2, \dots, a_k$ \) 是对应的指数。

2. **计算约数个数**：约数的个数可以通过以下公式计算：
   $$
   \text{约数的个数} = (a_1 + 1) \times (a_2 + 1) \times \dots \times (a_k + 1)
   $$
   这是因为对于每个质数 ( $p_i$ )，可以选择使用 ( $0$ ) 次到 ( $a_i$ ) 次共 ( $a_i + 1$ ) 种方式组合，所以所有可能的组合方式乘积就是约数的总个数。

假设要计算 60 的约数个数：

1. **分解质因数**：$( 60 = 2^2 \times 3^1 \times 5^1 )$
2. **计算约数个数**：$( (2+1) \times (1+1) \times (1+1) = 3 \times 2 \times 2 = 12 )$

所以，60 的约数有 12 个。

```cpp
#include <stdio.h>
#define MOD 1000000007
#define N 100000010
#define HASH_SIZE 1000003
int n, a;
int h[HASH_SIZE], e[N], ne[N], idx, zs[N];

int hash(int x) {
    return x % HASH_SIZE;
}

void add(int x) {
    
} 


void count(int x) {
    for (int i = 2; i <= x / i; i++) {
        if (x % i == 0) {
            int t = hash(i);
            int flag = 0;
            for (int j = h[t]; j != -1; j = ne[j]) {
                if (e[j] == i) {
                    flag = 1;
                    while (x % i == 0) {
                        zs[j]++;
                        x /= i;
                    }
                }
            } 
    
            if (flag == 0) {
                e[idx] = i;
                while (x % i == 0) {
                    zs[idx]++;
                    x /= i;
                }
                ne[idx] = h[t];
                h[t] = idx++;
            }
        }
    }
    // !!!可能会有一个大的约数
    if (x > 1) {
        int t = hash(x);
        int flag = 0;
        for (int j = h[t]; j != -1; j = ne[j]) {
            if (e[j] == x) {
                flag = 1;
                zs[j]++;
            }
        }
        if (flag == 0) {
            e[idx] = x;
            zs[idx]++;
            ne[idx] = h[t];
            h[t] = idx++;
        }
    }
}

int main() {
    for (int i = 0; i < HASH_SIZE; i++) {
        h[i] = -1;
    }
    scanf("%d", &n);
    while (n--) {
        scanf("%d", &a);
        count(a);
    }
    long long ans = 1;
    // printf("%d\n", max);
    for (int i = 0; i < HASH_SIZE; i++) {
        for (int j = h[i]; j != -1; j = ne[j]) {
            ans = ans * (zs[j] + 1) % MOD;
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

### [871. 约数之和 - AcWing题库](https://www.acwing.com/problem/content/873/)

要计算一个数的所有约数之和，可以通过分解质因数后，利用以下公式来计算：

1. **分解质因数**：将该数 \( N \) 分解为若干个质数的乘积，假设分解结果为：
   $$
   N = p_1^{a_1} \times p_2^{a_2} \times \dots \times p_k^{a_k}
   $$
   其中，\( $p_1, p_2, \dots, p_k$ \) 是质数，\( $a_1, a_2, \dots, a_k$ \) 是对应的指数。

2. **计算约数之和**：约数之和可以通过以下公式计算：
   $$
   \sigma(N) = \left(\frac{p_1^{a_1+1} - 1}{p_1 - 1}\right) \times \left(\frac{p_2^{a_2+1} - 1}{p_2 - 1}\right) \times \dots \times \left(\frac{p_k^{a_k+1} - 1}{p_k - 1}\right)
   $$
   这是因为对于每个质数 \( $p_i$ \)，其贡献可以表达为一个等比数列的和，计算等比数列的和后，所有这些和的乘积就是约数的总和。

```cpp
#include <stdio.h>
#define MOD 1000000007
#define N 10000010
#define HASH_SIZE 1000003
int n, a;
int h[HASH_SIZE], e[N], ne[N], idx;
int zs[N];
int hash(int x) {
    return x % HASH_SIZE;
}

void count(int x) {
    for (int i = 2; i <= x / i; i++) {
        if (x % i == 0) {
            int t = hash(i);
            int flag = 0;
            for (int j = h[t]; j != -1; j = ne[j]) {
                if (e[j] == i) {
                    flag = 1;
                    while (x % i == 0) {
                        zs[j]++;
                        x /= i;
                    }
                }
            }
            if (flag == 0) {
                e[idx] = i;
                while (x % i == 0) {
                    zs[idx]++;
                    x /= i;
                }
                ne[idx] = h[t];
                h[t] = idx++;
            }
        }
    }
    if (x > 1) {
    int t = hash(x);
    int flag = 0;
    for (int j = h[t]; j != -1; j = ne[j]) {
        if (e[j] == x) {
            flag = 1;
            // 这里应该只增加一次计数，而不是在while循环中
            zs[j]++;
            break; // 添加这一行来避免重复增加计数
        }
    }
    if (flag == 0) {
        e[idx] = x;
        zs[idx]++;
        ne[idx] = h[t];
        h[t] = idx++;
    } 
}
}

int main() {
    memset(h, -1, sizeof h);
    scanf("%d", &n);
    while (n--) {
        scanf("%d", &a);
        count(a);
    }
    long long ans = 1;
    for (int i = 0; i < HASH_SIZE; i++) {
        for (int j = h[i]; j != -1; j = ne[j]) {
            long long tmp = 1;
            int d = e[j], z = zs[j];
            // printf("t: %d, d: %d, z: %d\n", j, d, z);
            for (int k = 1; k <= z; k++) {
                tmp = (tmp * d + 1) % MOD; 
            }
            ans = ans * tmp % MOD;
        }
    }
    printf("%lld\n", ans);
    return 0;
}

```

### [872. 最大公约数 - AcWing题库](https://www.acwing.com/problem/content/description/874/)
```cpp
#include <stdio.h>

int gcb(int a, int b) {
    return b ? gcb(b, a % b) : a;
}

int n, a, b;
int main() {
    scanf("%d", &n);
    while (n--) {
        scanf("%d%d", &a, &b);
        printf("%d\n", gcb(a, b));
    }
    return 0;
}
```

## 4.3. 欧拉函数

欧拉函数（Euler's Totient Function），通常用符号 $\phi(n)$ 表示，是数论中的一个重要函数。对于一个正整数 $n$，欧拉函数 $\phi(n)$ 的值表示的是小于或等于 $n$ 的正整数中与 $n$ 互质的数的个数。

### 欧拉函数的定义

对于一个正整数 $n$，欧拉函数 $\phi(n)$ 的定义是：

$$
\phi(n) = |\{ 1 \leq k \leq n \mid \gcd(k, n) = 1 \}|$$

其中，$\gcd(k, n)$ 表示 $k$ 和 $n$ 的最大公约数。换句话说，$\phi(n)$ 是在 $1$ 到 $n$ 之间（包括 $n$）与 $n$ 互质的整数的个数。

### 欧拉函数的性质

1. **对于质数 $p$**： 如果 $n=p$ 是一个质数，那么 $\phi(p) = p - 1$。这是因为对于质数 $p$，从 $1$ 到 $p−1$ 的所有整数都与 $p$ 互质。
    
2. **欧拉函数的积性**： 如果 $m$ 和 $n$ 互质，那么 $\phi(mn) = \phi(m) \times \phi(n)$。这种性质称为欧拉函数的积性。
    
3. **欧拉函数的计算公式**： 如果 $n$ 的质因数分解为 $n = p_1^{a_1} \times p_2^{a_2} \times \dots \times p_k^{a_k}$，其中 $p_1, p_2, \dots, p_k$ 是 $n$ 的不同质因子，那么：
    
    $$
    \phi(n) = n \times \left( 1 - \frac{1}{p_1} \right) \times \left( 1 - \frac{1}{p_2} \right) \times \dots \times \left( 1 - \frac{1}{p_k} \right)
	$$

### [873. 欧拉函数 - AcWing题库](https://www.acwing.com/problem/content/875/)
```cpp
#include <stdio.h>
int n, a;
int main() {
    scanf("%d", &n);
    while (n--) {
        scanf("%d", &a);
        long long ans = a;
        for (int i = 2; i <= a / i; i++) {
            if (a % i == 0) {
                ans = ans * (i - 1) / i;
            }
            while (a % i == 0) {
                a /= i;
            }
        }
        if (a > 1) {
            ans = ans * (a - 1) / a;
        }
        printf("%lld\n", ans);
    }
    return 0;
}
```




## 4.4. 快速幂

快速幂（Exponentiation by Squaring）是一种高效计算大整数幂的方法。它通过将指数的二进制表示与幂的性质相结合，减少了计算次数，因此比直接的循环乘法更为高效。

### 快速幂的基本思想

快速幂算法利用了以下性质：

1. **幂的分解**：对于一个正整数 $n$ 和一个正整数 $a$，可以根据指数的奇偶性将幂分解：
    
    - 如果 $n$ 是偶数，那么： $a^n = (a^{n/2})^2$
    - 如果 $n$ 是奇数，那么： $a^n = a \times a^{n-1}$. 而 $a^{n-1}$ 又是偶数幂，因此可以继续使用第一种情况来分解。
2. **指数的二进制表示**：通过将指数 $n$ 表示为二进制数，可以将幂运算转化为一系列的平方和乘法操作。二进制表示法使得每次操作只需要考虑指数的二进制位是否为 1。
    

### 快速幂算法实现

快速幂算法可以通过递归或迭代的方式实现。以下是迭代版本的快速幂算法伪代码：

```plaintext
function modularExponentiation(a, n, m): 
	result = 1 
	base = a % m 
	while n > 0: 
		if n % 2 == 1: # 如果 n 是奇数 
			result = (result * base) % m 
		base = (base * base) % m # 计算 base 的平方，并取模 
		n = n // 2 # n 整除 2，向右移位 return result
```

### [875. 快速幂 - AcWing题库](https://www.acwing.com/problem/content/877/)
```cpp
#include <stdio.h>
long long n, a, b, p;

long long ksm() {
    long long res = 1;
    while (b) {
        if (b & 1 == 1) {
            res = res * a % p;
        }
        b >>= 1;
        a = a * a % p;
    }
    return res;
}

int main() {
    scanf("%lld", &n);
    while (n--) {
        scanf("%lld%lld%lld", &a, &b, &p);
        printf("%lld\n", ksm());
    }
    return 0;
}
```

### [876. 快速幂求逆元 - AcWing题库](https://www.acwing.com/problem/content/878/)

![[Pasted image 20240827143645.png]]
![[Pasted image 20240827143903.png]]

```cpp
#include <stdio.h>
long long n, a, p;

long long ksm(long long a, long long b, long long c) {
    long long ans = 1;
    while (b) {
        if (b & 1 == 1) {
            ans = ans * a % c;
        }
        b >>= 1;
        a = a * a % c;
    }
    return ans;
}

int main() {
    scanf("%lld", &n);
    while (n--) {
        scanf("%lld%lld", &a, &p);
        if (a % p == 0) {
            printf("impossible\n");
        } else {
            printf("%lld\n", ksm(a, p - 2, p));
        }
        
    }
    return 0;
}
```

---
# 第5讲  动态规划
## 5.1. 背包问题
### [2. 01背包问题 - AcWing题库](https://www.acwing.com/problem/content/2/)
```cpp
#include <stdio.h>
#define N 1010
int nn, vv, v[N], w[N], ans[N];

int max(int a, int b) {
    return a > b ? a : b;
}

int main() {
    scanf("%d%d", &nn, &vv);
    for (int i = 1; i <= nn; i++) {
        scanf("%d%d", &v[i], &w[i]);
        for (int j = vv; j >= v[i]; j--) {
            ans[j] = max(ans[j],  ans[j - v[i]] + w[i]);
        }
    }
    printf("%d\n", ans[vv]);
    return 0;
}

```

### [3. 完全背包问题 - AcWing题库](https://www.acwing.com/problem/content/3/)
```cpp
/*
原始的状态转移方程:
ans[i][j] = max(ans[i - 1][j], ans[i - 1][j - v[i]] + w[i], ans[i - 1][j - 2 * v[i]] + 2 * w[i], ……, ans[i - 1][j - k * v[i]] + k * w[i])
ans[i][j - v[i]] = max(        ans[i - 1][j - v[i]],        ans[i - 1][j - v[i]      + w[i], ......)

因此，ans[i][j] = max(ans[i - 1][j], ans[i][j - v[i]] + w[i])
*/

#include <stdio.h>
#define N 1010
int nn, vv, v[N], w[N], ans[N];

int max(int a, int b) {
    return a > b ? a : b;
}

int main() {
    scanf("%d%d", &nn, &vv);
    for (int i = 1; i <= nn; i++) {
        scanf("%d%d", &v[i], &w[i]);
        for (int j = v[i]; j <= vv; j++) {
            ans[j] = max(ans[j], ans[j - v[i]] + w[i]);
        }
    }
    printf("%d\n", ans[vv]);
    return 0;
}
```

### [4. 多重背包问题 I - AcWing题库](https://www.acwing.com/problem/content/4/)
```cpp
/*
f[i][j] = max(f[i - 1][j - k * v[i]] + k * w[i])  k <= s[i] && k * v[i] <= j
*/

#include <stdio.h>
#define N 110
int nn, vv, v[N], w[N], s[N], f[N][N];

int max(int a, int b) {
    return a > b ? a : b;
}

int main() {
    scanf("%d%d", &nn, &vv);
    for (int i = 1; i <= nn; i++) {
        scanf("%d%d%d", &v[i], &w[i], &s[i]);
        for (int j = 0; j <= vv; j++) {
            for (int k = 0; k <= s[i] && k * v[i] <= j; k++) {
                f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);
            }
        }
    }
    printf("%d\n", f[nn][vv]);
    return 0;
}
```

### [9. 分组背包问题 - AcWing题库](https://www.acwing.com/problem/content/9/)
```cpp
/*
f[i][j] = max(f[i-1][j], f[i-1][j-v[i][1]] + w[i][1], f[i-1][j-v[i][2]] + w[i][2]))
*/
#include <stdio.h>
#define N 110
int nn, vv;
int v[N][N], w[N][N], s[N], f[N][N];

int max(int a, int b) {
    return a > b ? a : b;
}

int main() {
    scanf("%d%d", &nn, &vv);
    for (int i = 1; i <= nn; i++) {
        scanf("%d", &s[i]);
        for (int j = 1; j <= s[i]; j++) {
            scanf("%d%d", &v[i][j], &w[i][j]);
        }
    }
    
    for (int i = 1; i <= nn; i++) { // 前i组物品
        for (int j = 1; j <= vv; j++) { // 总容量
            f[i][j] = f[i - 1][j];
            for (int k = 1; k <= s[i]; k++) { // 第i组的第k个物品
                if (j >= v[i][k]) {
                    f[i][j] = max(f[i][j], f[i - 1][j - v[i][k]] + w[i][k]);
                }
                
            }
        }
    }
    printf("%d\n", f[nn][vv]);
    return 0;
}
```

## 5.2. 线性DP

### [898. 数字三角形 - AcWing题库](https://www.acwing.com/problem/content/900/)
这道题需要注意边界条件的判断。
```cpp
#include <stdio.h>
#define N 510
int n, tag[N][N];
int max(int a, int b) {
    if (a == -0x3f3f3f3f) {
        if (b == -0x3f3f3f3f) {
            return 0;
        } else {
            return b;
        }
    } else {
        if (b == -0x3f3f3f3f) {
            return a;
        } else {
            return a > b ? a : b;
        }
    }
    
}
int main() {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            tag[i][j] = -0x3f3f3f3f;
        }
    }
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            scanf("%d", &tag[i][j]);
            tag[i][j] += max(tag[i - 1][j - 1], tag[i - 1][j]);
           
        }
    }
    int ans = -0x3f3f3f3f;
    for (int j = 1; j <= n; j++) {
        ans = max(ans, tag[n][j]);
    }
    printf("%d\n", ans);
    return 0;
}
```

### [895. 最长上升子序列 - AcWing题库](https://www.acwing.com/problem/content/897/)
```cpp
/*
f[i] = max(f[i - k] + 1)
*/

#include <stdio.h>
#define N 1010
int a[N], f[N], n;
int max(int a, int b) {
    return a > b ? a : b;
}
int ans = -1;
int main() {
    scanf("%d", &n);
    a[0] = 0x3f3f3f3f;
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        f[i] = 1;
        for (int k = 0; k < i; k++) {
            if (a[i] > a[k]) {
                f[i] = max(f[i], f[k] + 1);
            }
        }
        ans = max(ans, f[i]);
    }
    
    printf("%d\n", ans);
    return 0;
}
```

```cpp
/*
mw[i]表示长度为i的子序列最后一个元素的最小值
    0 1 2 3 4 5 6 7
i = 1: 3
    - 3 x x x x x x
i = 2: 1
    - 1 x x x x x x
i = 3: 2
    - 1 2 x x x x x
i = 4: 1
    - 1 2 x x x x x
i = 5: 8
    - 1 2 8 x x x x
i = 6: 5
    - 1 2 5 x x x x
i = 7: 6
    - 1 2 5 6 x x x
*/

#include <stdio.h>
#define N 100010
int a[N], n;
int q[N], cur_size = 0;
int ans = -1;

int find(int x) {
    int l = 1, r = cur_size; 
    while(l < r) {
        int mid = l + r >> 1;
        if(q[mid] >= x) r = mid;
        else l = mid + 1;
    }

    return l;
}

int main() {
    scanf("%d", &n);
    q[0] = -0x3f3f3f3f;
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        if (a[i] > q[cur_size]) {
            q[++cur_size] = a[i];
        } else {
            int j = find(a[i]);
            q[j] = a[i];
            

        }
        // for (int j = 0; j <= cur_size; j++) {
        //     printf("%d ", q[j]);
        // }
        // puts("");
    }
    printf("%d\n", cur_size);
    return 0;
}
```

### [897. 最长公共子序列 - AcWing题库](https://www.acwing.com/problem/content/899/)

```cpp
/*
f[i][j]表示字符串A的前i项和字符串B的前j项中最长的公共子序列。
考虑a[i]和b[j]是否相等。
a[i] == b[j] : f[i][j] = f[i - 1][j - 1] + 1
a[i] != b[j] : f[i][j] = max(f[i -1][j], f[i][j - 1])
*/
#include <stdio.h>
#define N 1010
int n, m, f[N][N];
char a[N], b[N];

int max(int x, int y) {
    return x > y ? x : y;
}

int main() {
    scanf("%d%d", &n, &m);
    scanf("%s%s", a + 1, b + 1);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (a[i] == b[j]) {
                f[i][j] = f[i - 1][j - 1] + 1;
            } else {
                f[i][j] = max(f[i - 1][j], f[i][j - 1]);
            }
        }
    }
    printf("%d\n", f[n][m]);
    return 0;
}
```