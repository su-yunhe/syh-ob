# 工作交接——Http流控验证 

> s50041542 
>  苏云鹤 
## 1. 概览 
工作内容基于netstack开源代码仓。 [communication\_netstack: 网络协议栈 (gitee.com)]([https://gitee.com/openharmony/communication_netstack)](https://gitee.com/openharmony/communication_netstack)) 
工作涉及到的文件如下。



|          文件          |                                                 位置                                                 |     说明      |     |                   |                                                                                    |      |     |                               |     |         |     |             |     |      |     |
| :------------------: | :------------------------------------------------------------------------------------------------: | :---------: | --- | ----------------- | ---------------------------------------------------------------------------------- | ---- | --- | ----------------------------- | --- | ------- | --- | ----------- | --- | ---- | --- |
| http_client_task.cpp |   code/foundation/communication/netstack/frameworks/native/http/http_client/http_client_task.cpp   | http流控的函数实现 |     |                   |                                                                                    |      |     |                               |     |         |     |             |     |      |     |
|  http_client_task.h  | code/foundation/communication/netstack/interfaces/innerkits/http_client/include/http_client_task.h | http流控的函数声明 |     | HttpSpeedTest.cpp | code/foundation/communication/netstack/test/unittest/http_client/HttpSpeedTest.cpp | 单元测试 |     | test_http_client_unittest.bat | 本地  | 自动化测试脚本 |     | result.xlsx | 本地  | 测试数据 |     |
## 2. 方案 
### 2.1. 限速方案 
限速方案主要针对使用了`libcurl`库的http/https连接。通过调用三方库提供的api（`CURLOPT_MAX_RECV_SPEED_LARGE`）进行限速。然而根据实测结果，中途限速会导致较长时间的0速率，影响体验。为了消除或减少0速率的时间，有2个方案。   
**方案1**   在需要限速的时候记录一下当前的传输进度，然后把当前的curl句柄停掉在新建一个新的，设置速度和已传输的字节数，然后再继续传输。   
**方案2**   在需要限速的时候记录一下当前的传输进度，然后调用api把当前的curl句柄恢复成初始状态从而清除关于速率的统计信息，重新设置速度和已传输的字节数，然后再继续传输。   
### 2.2. 测试方案 
1. 在有背景流量的情况下去访问一些网页，对比限速和不限速的情况下前景请求的速度是否有变化； 
2. 同时还要关注限速是否会对背景请求造成较大影响，比如断链或长时间0速率等。 

## 3. 代码说明 
### 3.1. `http_client_task.cpp` 
添加 `CleanupCurlHandle()` 函数，用于清理和释放与 CURL 句柄相关联的资源。 
```cpp
void HttpClientTask::CleanupCurlHandle() { 
	if (curlHeaderList_ != nullptr) {
		curl_slist_free_all(curlHeaderList_); 
		curlHeaderList_ = nullptr; 
	} 
	if (curlHandle_) { 
		curl_easy_cleanup(curlHandle_); 
		curlHandle_ = nullptr; 
	} 
}
```

添加 `GetDownloadedSizeSomehow` 函数，用于获取连接某时刻已经完成传输的字节数。
```cpp 
curl_off_t HttpClientTask::GetDownloadedSizeSomehow() { 
	curl_off_t downloadedSize = 0; 
	curl_easy_getinfo(curlHandle_, CURLINFO_SIZE_DOWNLOAD_T, &downloadedSize); 
	return downloadedSize; 
} 
``` 

添加 `SetMaxRecvSpeed` 函数，用于对http连接进行实际限速。
方案1： 
```cpp 
bool HttpClientTask::SetMaxRecvSpeed(curl_off_t maxspeed) { 
curl_off_t downloadedSize; // 记录当前已经下载的进度, 并关闭当前句柄 
if(curlHandle_) { 
	curl_off_t downloadedSize = GetDownloadedSizeSomehow(); // 获取当前已经下载的进度 
	curl_easy_pause(curlHandle_, CURLPAUSE_RECV); 
} // 清理资源 
CleanupCurlHandle(); // 创建新的 libcurl 句柄 
curlHandle_ = curl_easy_init(); 
if (!curlHandle_) { 
NETSTACK_LOGE("Failed to create new curl handle!"); 
return false; 
} 
// 设置新的 libcurl 选项 
SetCurlOptions(); // 设置最大接收速度 
NETSTACK_CURL_EASY_SET_OPTION(curlHandle_, CURLOPT_MAX_RECV_SPEED_LARGE, maxspeed); // 恢复之前的传输状态 
NETSTACK_CURL_EASY_SET_OPTION(curlHandle_, CURLOPT_RESUME_FROM_LARGE, downloadedSize); // 重新开始传输 
CURLcode code = curl_easy_perform(curlHandle_); 
if (code != CURLE_OK) { 
error_.SetCURLResult(code); 
return false; 
} 
return true; 
} 
``` 


方案2： ```cpp bool HttpClientTask::SetMaxRecvSpeed(curl_off_t maxspeed) { // 记录当前已经下载的进度 curl_off_t downloadedSize = 0; if(curlHandle_) { downloadedSize = GetDownloadedSizeSomehow(); } NETSTACK_LOGD("Current download size is %ld.", downloadedSize); if (curlHandle_) { curl_easy_reset(curlHandle_); } if (!SetCurlOptions()) { NETSTACK_LOGE("Failed to set curl options!"); return false; } // 设置最大接收速度 NETSTACK_CURL_EASY_SET_OPTION(curlHandle_, CURLOPT_MAX_RECV_SPEED_LARGE, maxspeed); // 恢复之前的传输状态 if (downloadedSize > 0) { NETSTACK_CURL_EASY_SET_OPTION(curlHandle_, CURLOPT_RESUME_FROM_LARGE, downloadedSize); } // 重新启动传输 usleep(1000); CURLcode code = curl_easy_perform(curlHandle_); if (code != CURLE_OK) { error_.SetCURLResult(code); NETSTACK_LOGE("Failed to restart transfer: %{public}s", curl_easy_strerror(code)); return false; } return true; } ``` ### 3.2. `http_client_task.h` 添加对应的函数声明。 `SetMaxRecvSpeed`： ```cpp /** * Retrieves the downloaded size of the HTTP request. * @return Returns the downloaded size if successful, otherwise returns 0. */ curl_off_t HttpClientTask::GetDownloadedSizeSomehow(); ``` `CleanupCurlHandle`： ```cpp /** * Cleans up the CURL handle and associated resources. */ void HttpClientTask::CleanupCurlHandle(); ``` `GetDownloadedSizeSomehow` : ```cpp /** * Sets the maximum receive speed for the HTTP request. * @param maxspeed The maximum receive speed to be set. * @return Returns true if the speed limit is set successfully, false otherwise. */ bool HttpClientTask::SetMaxRecvSpeed(curl_off_t maxspeed); ``` ### 3.3. `HttpSpeedTest.cpp` #### 3.3.1. 数据结构的设计 定义 `Request` 结构体，用于管理一个HTTP请求（前景、背景）。在里面配置了`OnDataReceive`和`OnSuccess`回调，用于更新和统计接收时间、数据量等，以及`Start()`和`SetMaxRecvSpeed(curl_off_t maxspeed)`。 ```cpp struct Request { string url; string method; chrono::steady_clock::time_point startTime; chrono::steady_clock::time_point lastReceivedTime; chrono::steady_clock::time_point finishTime; size_t totalReceived; shared_ptr<HttpClientTask> task; int startOther; // 只对背景请求考虑 int cntOnDataReceive; // 用于统计回调函数的调用次数，从而控制输出频率 long long duration; /** 构造函数, 提供请求url和类型 */ Request(const string& url, const string& method) : url(url), method(method), totalReceived(0), startOther(0), cntOnDataReceive(0), duration(-1) { HttpClientRequest httpReq; httpReq.SetURL(url); httpReq.SetMethod(method); HttpSession &session = HttpSession::GetInstance(); this -> task = session.CreateTask(httpReq); this -> task -> OnDataReceive([this](const HttpClientRequest &request, const uint8_t *data, size_t length) { this -> totalReceived += length; this -> cntOnDataReceive ++; this -> lastReceivedTime = chrono::steady_clock::now(); auto dura = chrono::duration_cast<chrono::seconds>(this -> lastReceivedTime - this -> startTime).count(); // 这是为了保证1s只输出1条记录 if (dura == this -> duration) { this -> duration = dura; return; } this -> duration = dura; double speed = (this -> totalReceived / dura) / 1024.0; cout << "Task [" << this -> url << "]: Total data: " << this -> totalReceived << "B, Speed: " << setprecision(2) << fixed << speed << " kB/s, Duration: " << dura << endl; }); this -> task -> OnSuccess([this](const HttpClientRequest &request, const HttpClientResponse &response) { this -> finishTime = chrono::steady_clock::now(); auto totalTime = chrono::duration_cast<chrono::milliseconds>(this -> finishTime - this -> startTime).count(); cout << "Task [" << this -> url << "] is finished. Total data: " << this -> totalReceived << ", Cost: " << totalTime << " ms." << endl; }); } void Start() { this -> task -> Start(); this -> startTime = chrono::steady_clock::now(); cout << "Task [" << this -> url << "] is started." << endl; } bool SetMaxRecvSpeed(curl_off_t maxspeed) { return this -> task -> SetMaxRecvSpeed(maxspeed); } }; ``` 用两个vector去分别存储前景请求和背景请求。 ```cpp vector<Request> backRequests; vector<Request> frontRequests; ``` 背景请求以大流量的下载任务为主；前景请求以获取网页首页为主。 ```cpp vector<string> backUrls = { "[https://mirrors.tuna.tsinghua.edu.cn/kernel/v6.x/linux-6.0.1.tar.xz&#34;](https://mirrors.tuna.tsinghua.edu.cn/kernel/v6.x/linux-6.0.1.tar.xz&#34;) }; vector<string> frontUrls = { "[https://www.huawei.com/cn/&#34;,](https://www.huawei.com/cn/&#34;,) "[https://www.zhihu.com/&#34;,](https://www.zhihu.com/&#34;,) "[https://www.vmall.com/index.html&#34;,](https://www.vmall.com/index.html&#34;,) "[https://www.jd.com/&#34;,](https://www.jd.com/&#34;,) "[https://www.taobao.com/&#34;,](https://www.taobao.com/&#34;,) "[https://blog.csdn.net/&#34;,](https://blog.csdn.net/&#34;,) "[https://www.bilibili.com/&#34;,](https://www.bilibili.com/&#34;,) "[https://v.qq.com/&#34;,](https://v.qq.com/&#34;,) "[https://www.iqiyi.com/&#34;,](https://www.iqiyi.com/&#34;,) "[https://youku.com/&#34;](https://youku.com/&#34;) }; ``` #### 3.3.2. 测试的单元用例 1. ​初始化请求； 2. ​启动后台请求​，并记录它们的开始时间； 3. ​一段时间后，限速并启动前台请求； 4. ​循环检查所有后台请求是否完成，直到它们全部完成； 5. ​输出测试结果。 ```cpp HWTEST_F(HttpSpeedTest, SpeedTest1, TestSize.Level1) { /** 初始化requests */ for (string url: backUrls) { backRequests.emplace_back(url, "GET"); } for (string url: frontUrls) { frontRequests.emplace_back(url, "GET"); } /** 启动背景请求 */ for (size_t i = 0; i < backRequests.size(); i++) { backRequests[i].Start(); } int flag = 0; while (Judge()) { this_thread::sleep_for(chrono::milliseconds(100)); if (!flag && chrono::duration_cast<chrono::seconds>(backRequests[0].lastReceivedTime - backRequests[0].startTime).count() >= 5) { for (size_t i = 0; i < backRequests.size(); i++) { backRequests[i].SetMaxRecvSpeed(static_cast<curl_off_t>(4L)); } this_thread::sleep_for(chrono::milliseconds(100)); for (size_t i = 0; i < frontRequests.size(); i++) { frontRequests[i].Start(); this_thread::sleep_for(chrono::milliseconds(100)); } flag = 1; } } /** 输出结果 */ cout << "============= Result ===================" << endl; for (Request r : frontRequests) { cout << "[" << r.url << "] : " << chrono::duration_cast<chrono::milliseconds>(r.finishTime - r.startTime).count() << "ms."; } } ``` ### 3.4. `test_http_client_unittest.bat` 脚本可以把生成物拷贝到手机，更改权限，打开调试日志并设置只输出netstack模块的，并在运行结束后将日志拷贝回电脑。 把测试的编译生成物拷贝到电脑对应路径下，运行测试脚本即可完成自动化测试。 ```bash hdc shell mount -o rw,remount / hdc hdc file send D:\Test\netstack\http_client_unittest\http_client_unittest /data pause hdc shell power-shell setmode 602 hdc shell chmod 777 ./data/http_client_unittest hdc shell param set persist.sys.hilog.binary.on false hdc shell param set persist.sys.hilog.debug.on true hdc shell hilog -b X hdc shell hilog -b D -D 0xD0015B0 hdc shell rm -rf ./data/log/hilog/* hdc shell rm -rf ./data/log/faultlog/faultlogger/* hdc shell hilog -w start hdc shell hilog -r hdc shell ./data/http_client_unittest hdc shell hilog -w stop mkdir log\hilog mkdir log\faultlogger hdc file recv ./data/log/hilog/ .\log\ hdc file recv ./data/log/faultlog/faultlogger/ .\log\ pause ``` ## 4. 测试结果 1. 多次测试对背景流量限速前后，访问网页的速度。结果表明限速可以有效提高，10个网页中9个的平均访问速度得到提高。 ![Alt text](image.png) 2. 若采用方案1，即断链重连的方式，背景连接的中断时间基本稳定在0.3s，速度在重新连接的第1s不太稳定，后面就会稳定下来，并且会导致连接句柄发生变化；若采用方案2，可以在不中断的情况下立刻降低到设置值。 ![Alt text](image-1.png)